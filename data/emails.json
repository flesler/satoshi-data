[
	{
		"date": "2008-11-03 01:37:43",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014815.html",
		"q": "We very, very much need such a system, but the way I understand your proposal, it does not seem to scale to the required size.\n\nFor transferable proof of work tokens to have value, they must have monetary value. To have monetary value, they must be transferred within a very large network - for example a file trading network akin to bittorrent.\n\nTo detect and reject a double spending event in a timely manner, one must have most past transactions of the coins in the transaction, which, naively implemented, requires each peer to have most past transactions, or most past transactions that occurred recently. If hundreds of millions of people are doing transactions, that is a lot of bandwidth - each must know all, or a substantial part thereof.",
		"a": "Long before the network gets anywhere near as large as that, it would be safe for users to use Simplified Payment Verification (section 8) to check for double spending, which only requires having the chain of block headers, or about 12KB per day. Only people trying to create new coins would need to run network nodes. At first, most users would run network nodes, but as the network grows beyond a certain point, it would be left more and more to specialists with server farms of specialized hardware. A server farm would only need to have one node on the network and the rest of the LAN connects with that one node.\n\nThe bandwidth might not be as prohibitive as you think. A typical transaction would be about 400 bytes (ECC is nicely compact). Each transaction has to be broadcast twice, so lets say 1KB per transaction. Visa processed 37 billion transactions in FY2008, or an average of 100 million transactions per day. That many transactions would take 100GB of bandwidth, or the size of 12 DVD or 2 HD quality movies, or about $18 worth of bandwidth at current prices.\n\nIf the network were to get that big, it would take several years, and by then, sending 2 HD movies over the Internet would probably not seem like a big deal."
	},
	{
		"date": "2008-11-03 16:23:49",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014818.html",
		"q": "But they don't. Bad guys routinely control zombie farms of 100,000 machines or more. People I know who run a blacklist of spam sending zombies tell me they often see a million new zombies a day.\n\nThis is the same reason that hashcash can't work on today's Internet -- the good guys have vastly less computational firepower than the bad guys.",
		"a": "Thanks for bringing up that point.\n\nI didn't really make that statement as strong as I could have. The requirement is that the good guys collectively have more CPU power than any single attacker.\n\nThere would be many smaller zombie farms that are not big enough to overpower the network, and they could still make money by generating bitcoins. The smaller farms are then the \"honest nodes\". (I need a better term than \"honest\") The more smaller farms resort to generating bitcoins, the higher the bar gets to overpower the network, making larger farms also too small to overpower it so that they may as well generate bitcoins too. According to the \"long tail\" theory, the small, medium and merely large farms put together should add up to a lot more than the biggest zombie farm.\n\nEven if a bad guy does overpower the network, it's not like he's instantly rich. All he can accomplish is to take back money he himself spent, like bouncing a check. To exploit it, he would have to buy something from a merchant, wait till it ships, then overpower the network and try to take his money back. I don't think he could make as much money trying to pull a carding scheme like that as he could by generating bitcoins. With a zombie farm that big, he could generate more bitcoins than everyone else combined.\n\nThe Bitcoin network might actually reduce spam by diverting zombie farms to generating bitcoins instead."
	},
	{
		"date": "2008-11-06 20:15:40",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014823.html",
		"q": "[Lengthy exposition of vulnerability of a systm to use-of-force monopolies ellided.]\n\nYou will not find a solution to political problems in cryptography.",
		"a": "Yes, but we can win a major battle in the arms race and gain a new territory of freedom for several years.\n\nGovernments are good at cutting off the heads of a centrally controlled networks like Napster, but pure P2P networks like Gnutella and Tor seem to be holding their own."
	},
	{
		"date": "2008-11-08 18:54:38",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014831.html",
		"q": "the \"currency\" is inflationary at about 35% as that's how much faster computers get annually ... the inflation rate of 35% is almost guaranteed by the technology",
		"a": "Increasing hardware speed is handled: \"To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases.\"\n\nAs computers get faster and the total computing power applied to creating bitcoins increases, the difficulty increases proportionally to keep the total new production constant. Thus, it is known in advance how many new bitcoins will be created every year in the future.\n\nThe fact that new coins are produced means the money supply increases by a planned amount, but this does not necessarily result in inflation. If the supply of money increases at the same rate that the number of people using it increases, prices remain stable. If it does not increase as fast as demand, there will be deflation and early holders of money will see its value increase.\n\nCoins have to get initially distributed somehow, and a constant rate seems like the best formula."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "it is mentioned that if a broadcast transaction does not reach all nodes, it is OK, as it will get into the block chain before long. How does this happen - what if the node that creates the \"next\" block (the first node to find the hashcash collision) did not hear about the transaction, and then a few more blocks get added also by nodes that did not hear about that transaction? Do all the nodes that did hear it keep that transaction around, hoping to incorporate it into a block once they get lucky enough to be the one which finds the next collision?",
		"a": "Right, nodes keep transactions in their working set until they get into a block. If a transaction reaches 90% of nodes, then each time a new block is found, it has a 90% chance of being in it."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "Or for example, what if a node is keeping two or more chains around as it waits to see which grows fastest, and a block comes in for chain A which would include a double-spend of a coin that is in chain B? Is that checked for or not? (This might happen if someone double-spent and two different sets of nodes heard about the two different transactions with the same coin.)",
		"a": "That does not need to be checked for. The transaction in whichever branch ends up getting ahead becomes the valid one, the other is invalid. If someone tries to double spend like that, one and only one spend will always become valid, the others invalid.\n\nReceivers of transactions will normally need to hold transactions for perhaps an hour or more to allow time for this kind of possibility to be resolved. They can still re-spend the coins immediately, but they should wait before taking an action such as shipping goods."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "I also don't understand exactly how double-spending, or cancelling transactions, is accomplished by a superior attacker who is able to muster more computing power than all the honest participants. I see that he can create new blocks and add them to create the longest chain, but how can he erase or add old transactions in the chain? As the attacker sends out his new blocks, aren't there consistency checks which honest nodes can perform, to make sure that nothing got erased? More explanation of this attack would be helpful, in order to judge the gains to an attacker from this, versus simply using his computing power to mint new coins honestly.",
		"a": "The attacker isn't adding blocks to the end. He has to go back and redo the block his transaction is in and all the blocks after it, as well as any new blocks the network keeps adding to the end while he's doing that. He's rewriting history. Once his branch is longer, it becomes the new valid one.\n\nThis touches on a key point. Even though everyone present may see the shenanigans going on, there's no way to take advantage of that fact.\n\nIt is strictly necessary that the longest chain is always considered the valid one. Nodes that were present may remember that one branch was there first and got replaced by another, but there would be no way for them to convince those who were not present of this. We can't have subfactions of nodes that cling to one branch that they think was first, others that saw another branch first, and others that joined later and never saw what happened. The CPU power proof-of-work vote must have the final say. The only way for everyone to stay on the same page is to believe that the longest chain is always the valid one, no matter what."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "As far as the spending transactions, what checks does the recipient of a coin have to perform? Does she need to go back through the coin's entire history of transfers, and make sure that every transaction on the list is indeed linked into the \"timestamp\" block chain? Or can she just do the latest one?",
		"a": "The recipient just needs to verify it back to a depth that is sufficiently far back in the block chain, which will often only require a depth of 2 transactions. All transactions before that can be discarded."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "Do the timestamp nodes check transactions, making sure that the previous transaction on a coin is in the chain, thereby enforcing the rule that all transactions in the chain represent valid coins?",
		"a": "Right, exactly. When a node receives a block, it checks the signatures of every transaction in it against previous transactions in blocks. Blocks can only contain transactions that depend on valid transactions in previous blocks or the same block. Transaction C could depend on transaction B in the same block and B depends on transaction A in an earlier block."
	},
	{
		"date": "2008-11-09 01:58:48",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014832.html",
		"q": "Sorry about all the questions, but as I said this does seem to be a very promising and original idea, and I am looking forward to seeing how the concept is further developed. It would be helpful to see a more process oriented description of the idea, with concrete details of the data structures for the various objects (coins, blocks, transactions), the data which is included in messages, and algorithmic descriptions of the procedures for handling the various events which would occur in this system. You mentioned that you are working on an implementation, but I think a more formal, text description of the system would be a helpful next step.",
		"a": "I appreciate your questions. I actually did this kind of backwards. I had to write all the code before I could convince myself that I could solve every problem, then I wrote the paper. I think I will be able to release the code sooner than I could write a detailed spec. You're already right about most of your assumptions where you filled in the blanks."
	},
	{
		"date": "2008-11-09 03:09:49",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014833.html",
		"q": "The core concept is that lots of entities keep complete and consistent information as to who owns which bitcoins.\n\nBut maintaining consistency is tricky. It is not clear to me what happens when someone reports one transaction to one maintainer, and someone else transports another transaction to another maintainer. The transaction cannot be known to be valid until it has been incorporated into a globally shared view of all past transactions, and no one can know that a globally shared view of all past transactions is globally shared until after some time has passed, and after many new transactions have arrived.\n\nDid you explain how to do this, and it just passed over my head, or were you confident it could be done, and a bit vague as to the details?",
		"a": "The proof-of-work chain is the solution to the synchronisation problem, and to knowing what the globally shared view is without having to trust anyone.\n\nA transaction will quickly propagate throughout the network, so if two versions of the same transaction were reported at close to the same time, the one with the head start would have a big advantage in reaching many more nodes first. Nodes will only accept the first one they see, refusing the second one to arrive, so the earlier transaction would have many more nodes working on incorporating it into the next proof-of-work. In effect, each node votes for its viewpoint of which transaction it saw first by including it in its proof-of-work effort.\n\nIf the transactions did come at exactly the same time and there was an even split, it's a toss up based on which gets into a proof-of-work first, and that decides which is valid.\n\nWhen a node finds a proof-of-work, the new block is propagated throughout the network and everyone adds it to the chain and starts working on the next block after it. Any nodes that had the other transaction will stop trying to include it in a block, since it's now invalid according to the accepted chain.\n\nThe proof-of-work chain is itself self-evident proof that it came from the globally shared view. Only the majority of the network together has enough CPU power to generate such a difficult chain of proof-of-work. Any user, upon receiving the proof-of-work chain, can see what the majority of the network has approved. Once a transaction is hashed into a link that's a few links back in the chain, it is firmly etched into the global history."
	},
	{
		"date": "2008-11-09 16:31:26",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014838.html",
		"q": "OK, suppose one node incorporates a bunch of transactions in its proof of work, all of them honest legitimate single spends and another node incorporates a different bunch of transactions in its proof of work, all of them equally honest legitimate single spends, and both proofs are generated at about the same time.\n\nWhat happens then?",
		"a": "They both broadcast their blocks. All nodes receive them and keep both, but only work on the one they received first. We'll suppose exactly half received one first, half the other.\n\nIn a short time, all the transactions will finish propagating so that everyone has the full set. The nodes working on each side will be trying to add the transactions that are missing from their side. When the next proof-of-work is found, whichever previous block that node was working on, that branch becomes longer and the tie is broken. Whichever side it is, the new block will contain the other half of the transactions, so in either case, the branch will contain all transactions. Even in the unlikely event that a split happened twice in a row, both sides of the second split would contain the full set of transactions anyway.\n\nIt's not a problem if transactions have to wait one or a few extra cycles to get into a block."
	},
	{
		"date": "2008-11-10 02:14:30",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014842.html",
		"q": "Furthermore, it cannot be made to work, as in the proposed system the work of tracking who owns what coins is paid for by seigniorage, which requires inflation.",
		"a": "If you're having trouble with the inflation issue, it's easy to tweak it for transaction fees instead. It's as simple as this: let the output value from any transaction be 1 cent less than the input value. Either the client software automatically writes transactions for 1 cent more than the intended payment value, or it could come out of the payee's side. The incentive value when a node finds a proof-of-work for a block could be the total of the fees in the block."
	},
	{
		"date": "2008-11-10 22:18:20",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014843.html",
		"q": "So what happened to the coin that lost the race?\n\n... it is a bit harsh if the guy who came second is likely to lose his coin.",
		"a": "When there are multiple double-spent versions of the same transaction, one and only one will become valid.\n\nThe receiver of a payment must wait an hour or so before believing that it's valid. The network will resolve any possible double-spend races by then.\n\nThe guy who received the double-spend that became invalid never thought he had it in the first place. His software would have shown the transaction go from \"unconfirmed\" to \"invalid\". If necessary, the UI can be made to hide transactions until they're sufficiently deep in the block chain."
	},
	{
		"date": "2008-11-10 22:18:20",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014843.html",
		"q": "Further, your description of events implies restrictions on timing and coin generation - that the entire network generates coins slowly compared to the time required for news of a new coin to flood the network",
		"a": "Sorry if I didn't make that clear. The target time between blocks will probably be 10 minutes.\n\nEvery block includes its creation time. If the time is off by more than 36 hours, other nodes won't work on it. If the timespan over the last 6*24*30 blocks is less than 15 days, blocks are being generated too fast and the proof-of-work difficulty doubles. Everyone does the same calculation with the same chain data, so they all get the same result at the same link in the chain."
	},
	{
		"date": "2008-11-10 22:18:20",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014843.html",
		"q": "We want spenders to have certainty that their transaction is valid at the time it takes a spend to flood the network, not at the time it takes for branch races to be resolved.",
		"a": "Instantant non-repudiability is not a feature, but it's still much faster than existing systems. Paper cheques can bounce up to a week or two later. Credit card transactions can be contested up to 60 to 180 days later. Bitcoin transactions can be sufficiently irreversible in an hour or two."
	},
	{
		"date": "2008-11-10 22:18:20",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014843.html",
		"q": "If one node is ignoring all spends that it does not care about, it suffers no adverse consequences.",
		"a": "With the transaction fee based incentive system I recently posted, nodes would have an incentive to include all the paying transactions they receive."
	},
	{
		"date": "2008-11-13 22:56:55",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014849.html",
		"q": "It is not sufficient that everyone knows X. We also need everyone to know that everyone knows X, and that everyone knows that everyone knows that everyone knows X - which, as in the Byzantine Generals problem, is the classic hard problem of distributed data processing.",
		"a": "The proof-of-work chain is a solution to the Byzantine Generals' Problem. I'll try to rephrase it in that context.\n\nA number of Byzantine Generals each have a computer and want to attack the King's wi-fi by brute forcing the password, which they've learned is a certain number of characters in length. Once they stimulate the network to generate a packet, they must crack the password within a limited time to break in and erase the logs, otherwise they will be discovered and get in trouble. They only have enough CPU power to crack it fast enough if a majority of them attack at the same time.\n\nThey don't particularly care when the attack will be, just that they all agree. It has been decided that anyone who feels like it will announce a time, and whatever time is heard first will be the official attack time. The problem is that the network is not instantaneous, and if two generals announce different attack times at close to the same time, some may hear one first and others hear the other first.\n\nThey use a proof-of-work chain to solve the problem. Once each general receives whatever attack time he hears first, he sets his computer to solve an extremely difficult proof-of-work problem that includes the attack time in its hash. The proof-of-work is so difficult, it's expected to take 10 minutes of them all working at once before one of them finds a solution. Once one of the generals finds a proof-of-work, he broadcasts it to the network, and everyone changes their current proof-of-work computation to include that proof-of-work in the hash they're working on. If anyone was working on a different attack time, they switch to this one, because its proof-of-work chain is now longer.\n\nAfter two hours, one attack time should be hashed by a chain of 12 proofs-of-work. Every general, just by verifying the difficulty of the proof-of-work chain, can estimate how much parallel CPU power per hour was expended on it and see that it must have required the majority of the computers to produce that much proof-of-work in the allotted time. They had to all have seen it because the proof-of-work is proof that they worked on it. If the CPU power exhibited by the proof-of-work chain is sufficient to crack the password, they can safely attack at the agreed time.\n\nThe proof-of-work chain is how all the synchronisation, distributed database and global view problems you've asked about are solved."
	},
	{
		"date": "2008-11-14 18:55:35",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014853.html",
		"q": "I think it is necessary that nodes keep a separate pending-transaction list associated with each candidate chain. ... One might also ask ... how many candidate chains must a given node keep track of at one time, on average?",
		"a": "Fortunately, it's only necessary to keep a pending-transaction pool for the current best branch. When a new block arrives for the best branch, ConnectBlock removes the block's transactions from the pending-tx pool. If a different branch becomes longer, it calls DisconnectBlock on the main branch down to the fork, returning the block transactions to the pending-tx pool, and calls ConnectBlock on the new branch, sopping back up any transactions that were in both branches. It's expected that reorgs like this would be rare and shallow.\n\nWith this optimisation, candidate branches are not really any burden. They just sit on the disk and don't require attention unless they ever become the main chain."
	},
	{
		"date": "2008-11-14 18:55:35",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014853.html",
		"q": "Or as James raised earlier, if the network broadcast is reliable but depends on a potentially slow flooding algorithm, how does that impact performance?",
		"a": "Broadcasts will probably be almost completely reliable. TCP transmissions are rarely ever dropped these days, and the broadcast protocol has a retry mechanism to get the data from other nodes after a while. If broadcasts turn out to be slower in practice than expected, the target time between blocks may have to be increased to avoid wasting resources. We want blocks to usually propagate in much less time than it takes to generate them, otherwise nodes would spend too much time working on obsolete blocks.\n\nI'm planning to run an automated test with computers randomly sending payments to each other and randomly dropping packets."
	},
	{
		"date": "2008-11-14 18:55:35",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014853.html",
		"q": "3. The bitcoin system turns out to be socially useful and valuable, so that node operators feel that they are making a beneficial contribution to the world by their efforts (similar to the various \"@Home\" compute projects where people volunteer their compute resources for good causes).\n\nIn this case it seems to me that simple altruism can suffice to keep the network running properly.",
		"a": "It's very attractive to the libertarian viewpoint if we can explain it properly. I'm better with code than with words though."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "Okay.... I'm going to summarize this protocol as I understand it.\n\nI'm filling in some operational details that aren't in the paper\n\nby supplementing what you wrote with what my own \"design sense\"\n\ntells me are critical missing bits or \"obvious\" methodologies for\n\nuse.\n\nFirst, people spend computer power creating a pool of coins to use\n\nas money. Each coin is a proof-of-work meeting whatever criteria\n\nwere in effect for money at the time it was created. The time of\n\ncreation (and therefore the criteria) is checkable later because\n\npeople can see the emergence of this particular coin in the\n\ntransaction chain and track it through all its \"consensus view\"\n\nspends. (more later on coin creation tied to adding a link).\n\nWhen a coin is spent, the buyer and seller digitally sign a (blinded)\n\ntransaction record, and broadcast it to a bunch of nodes whose purpose\n\nis keeping track of consensus regarding coin ownership. If someone\n\ndouble spends, then the transaction record can be unblinded revealing\n\nthe identity of the cheater. This is done via a fairly standard cut-\n\nand-choose algorithm where the buyer responds to several challenges\n\nwith secret shares, and the seller then asks him to \"unblind\" and\n\nchecks all but one, verifying that they do contain secret shares any\n\ntwo of which are sufficient to identify the buyer. In this case the\n\nseller accepts the unblinded spend record as \"probably\" containing\n\na valid secret share.\n\nThe nodes keeping track of consensus regarding coin ownership are in\n\na loop where they are all trying to \"add a link\" to the longest chain\n\nthey've so far recieved. They have a pool of reported transactions\n\nwhich they've not yet seen in a \"consensus\" signed chain. I'm going\n\nto call this pool \"A\". They attempt to add a link to the chain by\n\nmoving everything from pool A into a pool \"L\" and using a CPU-\n\nintensive digital signature algorithm to sign the chain including\n\nthe new block L. This results in a chain extended by a block\n\ncontaining all the transaction records they had in pool L, plus\n\nthe node's digital signature. While they do this, new\n\ntransaction records continue to arrive and go into pool A again\n\nfor the next cycle of work.\n\nThey may also recieve chains as long as the one they're trying to\n\nextend while they work, in which the last few \"links\" are links\n\nthat are *not* in common with the chain on which they're working.\n\nThese they ignore. (? Do they ignore them? Under what\n\ncircumstances would these become necessary to ever look at again,\n\nbearing in mind that any longer chain based on them will include\n\nthem?)\n\nBut if they recieve a _longer_ chain while working, they\n\nimmediately check all the transactions in the new links to make\n\nsure it contains no double spends and that the \"work factors\" of\n\nall new links are appropriate. If it contains a double spend,\n\nthen they create a \"transaction\" which is a proof of double\n\nspending, add it to their pool A, broadcast it, and continue work.\n\nIf one of the \"new\" links has an inappropriate work factor (ie,\n\nsomeone didn't put enough CPU into it for it to be \"licit\"\n\naccording to the rules) a new \"transaction\" which is a proof\n\nof the protocol violation by the link-creating node is created,\n\nbroadcast, and added to pool A, and the chain is rejected. In\n\nthe case of no double spends and appropriate work factors for\n\nall links not yet seen, they accept the new chain as consensus.\n\nIf the new chain is accepted, then they give up on adding their\n\ncurrent link, dump all the transactions from pool L back into pool\n\nA (along with transactions they've recieved or created since\n\nstarting work), eliminate from pool A those transaction records\n\nwhich are already part of a link in the new chain, and start work\n\nagain trying to extend the new chain.\n\nIf they complete work on a chain extended with their new link, they\n\nbroadcast it and immediately start work on another new link with\n\nall the transactions that have accumulated in pool A since they\n\nbegan work.\n\nDo I understand it correctly?\n\nIs there a mechanism to make sure that the \"chain\" does not consist\n\nsolely of links added by just the 3 or 4 fastest nodes? 'Cause a\n\nbroadcast transaction record could easily miss those 3 or 4 nodes\n\nand if it does, and those nodes continue to dominate the chain, the\n\ntransaction might never get added.\n\nTo remedy this, you need to either ensure provable propagation of\n\ntransactions, or vary the work factor for a node depending on how\n\nmany links have been added since that node's most recent link.\n\nUnfortunately, both measures can be defeated by sock puppets.\n\nThis is probably the worst problem with your protocol as it\n\nstands right now; you need some central point to control the\n\nidentities (keys) of the nodes and prevent people from making\n\nnew sock puppets.\n\nProvable propagation would mean that When Bob accepts a new chain\n\nfrom Alice, he needs to make sure that Alice has (or gets) all\n\ntransactions in his \"A\" and \"L\" pools. He sends them, and\n\nAlice sends back a signed hash to prove she got them. Once\n\nAlice has recieved this block of transactions, if any subsequent\n\nchains including a link added by Alice do not include those\n\ntransactions at or before that link, then Bob should be able to\n\npublish the block he sent Alice, along with her signature, in a\n\ntransaction as proof that Alice violated protocol. Sock puppets\n\ndefeat this because Alice just signs subsequent chains using a\n\nnew key, pretending to be a different node.\n\nIf we go with varying the work factor depending on how many new\n\nlinks there are, then we're right back to domination by the 3\n\nor 4 fastest nodes, except now they're joined by 600 or so\n\nsock puppets which they use to avoid the work factor penalty.\n\nIf we solve the sock-puppet issue, or accept that there's a central\n\npoint controlling the generation of new keys, then generation of\n\ncoins should be tied to the act of successfully adding a block to\n\nthe \"consensus\" chain. This is simple to do; creation of a coin\n\nis a transaction, it gets added along with all the other transactions\n\nin the block. But you can only create one coin per link, and of\n\ncourse if your version of the chain isn't the one that gets accepted,\n\nthen in the \"accepted\" view you don't have the coin and can't spend\n\nit. This gives the people maintaining the consensus database a\n\nreason to spend CPU cycles, especially since the variance in work\n\nfactor by number of links added since their own last link (outlined\n\nabove) guarantees that everyone, not just the 3 or 4 fastest nodes,\n\noccasionally gets the opportunity to create a coin.\n\nAlso, the work requirement for adding a link to the chain should\n\nvary (again exponentially) with the number of links added to that\n\nchain in the previous week, causing the rate of coin generation\n\n(and therefore inflation) to be strictly controlled.\n\nYou need coin aggregation for this to scale. There needs to be\n\na \"provable\" transaction where someone retires ten single coins\n\nand creates a new coin with denomination ten, etc. This is not\n\ntoo hard, using the same infrastructure you've already got; it\n\nsimply becomes part of the chain, and when the chain is accepted\n\nconsensus, then everybody can see that it happened.\n\nBear",
		"a": "I'll try and hurry up and release the sourcecode as soon as possible to serve as a reference to help clear up all these implementation questions."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "When a coin is spent, the buyer and seller digitally sign a (blinded) transaction record.",
		"a": "Only the buyer signs, and there's no blinding."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "If someone double spends, then the transaction record can be unblinded revealing the identity of the cheater.",
		"a": "Identities are not used, and there's no reliance on recourse. It's all prevention."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "This is done via a fairly standard cut-and-choose algorithm where the buyer responds to several challenges with secret shares",
		"a": "No challenges or secret shares. A basic transaction is just what you see in the figure in section 2. A signature (of the buyer) satisfying the public key of the previous transaction, and a new public key (of the seller) that must be satisfied to spend it the next time."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "They may also receive chains as long as the one they're trying to extend while they work, in which the last few \"links\" are links that are *not* in common with the chain on which they're working. These they ignore.",
		"a": "Right, if it's equal in length, ties are broken by keeping the earliest one received."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "If it contains a double spend, then they create a \"transaction\" which is a proof of double spending, add it to their pool A, broadcast it, and continue work.",
		"a": "There's no need for reporting of \"proof of double spending\" like that. If the same chain contains both spends, then the block is invalid and rejected.\n\nSame if a block didn't have enough proof-of-work. That block is invalid and rejected. There's no need to circulate a report about it. Every node could see that and reject it before relaying it.\n\nIf there are two competing chains, each containing a different version of the same transaction, with one trying to give money to one person and the other trying to give the same money to someone else, resolving which of the spends is valid is what the whole proof-of-work chain is about.\n\nWe're not \"on the lookout\" for double spends to sound the alarm and catch the cheater. We merely adjudicate which one of the spends is valid. Receivers of transactions must wait a few blocks to make sure that resolution has had time to complete. Would be cheaters can try and simultaneously double-spend all they want, and all they accomplish is that within a few blocks, one of the spends becomes valid and the others become invalid. Any later double-spends are immediately rejected once there's already a spend in the main chain.\n\nEven if an earlier spend wasn't in the chain yet, if it was already in all the nodes' pools, then the second spend would be turned away by all those nodes that already have the first spend."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "If the new chain is accepted, then they give up on adding their current link, dump all the transactions from pool L back into pool A (along with transactions they've received or created since starting work), eliminate from pool A those transaction records which are already part of a link in the new chain, and start work again trying to extend the new chain.",
		"a": "Right. They also refresh whenever a new transaction comes in, so L pretty much contains everything in A all the time."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "CPU-intensive digital signature algorithm to sign the chain including the new block L.",
		"a": "It's a Hashcash style SHA-256 proof-of-work (partial pre-image of zero), not a signature."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "Is there a mechanism to make sure that the \"chain\" does not consist solely of links added by just the 3 or 4 fastest nodes? 'Cause a broadcast transaction record could easily miss those 3 or 4 nodes and if it does, and those nodes continue to dominate the chain, the transaction might never get added.",
		"a": "If you're thinking of it as a CPU-intensive digital signing, then you may be thinking of a race to finish a long operation first and the fastest always winning.\n\nThe proof-of-work is a Hashcash style SHA-256 collision finding. It's a memoryless process where you do millions of hashes a second, with a small chance of finding one each time. The 3 or 4 fastest nodes' dominance would only be proportional to their share of the total CPU power. Anyone's chance of finding a solution at any time is proportional to their CPU power.\n\nThere will be transaction fees, so nodes will have an incentive to receive and include all the transactions they can. Nodes will eventually be compensated by transaction fees alone when the total coins created hits the pre-determined ceiling."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "Also, the work requirement for adding a link to the chain should vary (again exponentially) with the number of links added to that chain in the previous week, causing the rate of coin generation (and therefore inflation) to be strictly controlled.",
		"a": "Right."
	},
	{
		"date": "2008-11-15 04:43:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014858.html",
		"q": "You need coin aggregation for this to scale. There needs to be a \"provable\" transaction where someone retires ten single coins and creates a new coin with denomination ten, etc.",
		"a": "Every transaction is one of these. Section 9, Combining and Splitting Value."
	},
	{
		"date": "2008-11-15 18:02:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014860.html",
		"q": "One way to do this would be to have the person recieving the coin generate an asymmetric key pair, and then have half of it published with the transaction. In order to spend the coin later, s/he must demonstrate posession of the other half of the asymmetric key pair, probably by using it to sign the key provided by the new seller.",
		"a": "Right, it's ECC digital signatures. A new key pair is used for every\n\ntransaction.\n\nIt's not pseudonymous in the sense of nyms identifying people, but it\n\nis at least a little pseudonymous in that the next action on a coin\n\ncan be identified as being from the owner of that coin."
	},
	{
		"date": "2008-11-15 18:02:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014860.html",
		"q": "Mmmm. I don't know if I'm comfortable with that. You're saying there's no effort to identify and exclude nodes that don't cooperate? I suspect this will lead to trouble and possible DOS attacks.",
		"a": "There is no reliance on identifying anyone. As you've said, it's\n\nfutile and can be trivially defeated with sock puppets.\n\nThe credential that establishes someone as real is the ability to\n\nsupply CPU power."
	},
	{
		"date": "2008-11-15 18:02:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014860.html",
		"q": "Until.... until what? How does anybody know when a transaction has become irrevocable? Is \"a few\" blocks three? Thirty? A hundred? Does it depend on the number of nodes? Is it logarithmic or linear in number of nodes?",
		"a": "Section 11 calculates the worst case under attack. Typically, 5 or\n\n10 blocks is enough for that. If you're selling something that\n\ndoesn't merit a network-scale attack to steal it, in practice you\n\ncould cut it closer."
	},
	{
		"date": "2008-11-15 18:02:00",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014860.html",
		"q": "But in the absence of identity, there's no downside to them if spends become invalid, if they've already received the goods they double-spent for (access to website, download, whatever). The merchants are left holding the bag with \"invalid\" coins, unless they wait that magical \"few blocks\" (and how can they know how many?) before treating the spender as having paid.\n\nThe consumers won't do this if they spend their coin and it takes an hour to clear before they can do what they spent their coin on. The merchants won't do it if there's no way to charge back a customer when they find the that their coin is invalid because the customer has doublespent.",
		"a": "This is a version 2 problem that I believe can be solved fairly\n\nsatisfactorily for most applications.\n\nThe race is to spread your transaction on the network first. Think 6\n\ndegrees of freedom -- it spreads exponentially. It would only take\n\nsomething like 2 minutes for a transaction to spread widely enough\n\nthat a competitor starting late would have little chance of grabbing\n\nvery many nodes before the first one is overtaking the whole network.\n\nDuring those 2 minutes, the merchant's nodes can be watching for a\n\ndouble-spent transaction. The double-spender would not be able to\n\nblast his alternate transaction out to the world without the merchant\n\ngetting it, so he has to wait before starting.\n\nIf the real transaction reaches 90% and the double-spent tx reaches\n\n10%, the double-spender only gets a 10% chance of not paying, and 90%\n\nchance his money gets spent. For almost any type of goods, that's\n\nnot going to be worth it for the scammer.\n\nInformation based goods like access to website or downloads are\n\nnon-fencible. Nobody is going to be able to make a living off\n\nstealing access to websites or downloads. They can go to the file\n\nsharing networks to steal that. Most instant-access products aren't\n\ngoing to have a huge incentive to steal.\n\nIf a merchant actually has a problem with theft, they can make the\n\ncustomer wait 2 minutes, or wait for something in e-mail, which many\n\nalready do. If they really want to optimize, and it's a large\n\ndownload, they could cancel the download in the middle if the\n\ntransaction comes back double-spent. If it's website access,\n\ntypically it wouldn't be a big deal to let the customer have access\n\nfor 5 minutes and then cut off access if it's rejected. Many such\n\nsites have a free trial anyway."
	},
	{
		"date": "2008-11-17 17:24:43",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014863.html",
		"q": "This requires that we know, that is to say an honest well behaved peer whose communications and data storage is working well knows, what the current best branch is -",
		"a": "I mean a node only needs the pending-tx pool for the best branch it\n\nhas. The branch that it currently thinks is the best branch.\n\nThat's the branch it'll be trying to make a block out of, which is\n\nall it needs the pool for."
	},
	{
		"date": "2008-11-17 17:24:43",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014863.html",
		"q": "Rather than assuming that each message arrives at least once, we have to make a mechanism such that the information arrives even though conveyed by messages that frequently fail to arrive.",
		"a": "I think I've got the peer networking broadcast mechanism covered.\n\nEach node sends its neighbours an inventory list of hashes of the\n\nnew blocks and transactions it has. The neighbours request the\n\nitems they don't have yet. If the item never comes through after a\n\ntimeout, they request it from another neighbour that had it. Since\n\nall or most of the neighbours should eventually have each item,\n\neven if the coms get fumbled up with one, they can get it from any\n\nof the others, trying one at a time.\n\nThe inventory-request-data scheme introduces a little latency, but\n\nit ultimately helps speed more by keeping extra data blocks off the\n\ntransmit queues and conserving bandwidth."
	},
	{
		"date": "2008-11-17 17:24:43",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2008-November/014863.html",
		"q": "You have an outline and proposal for such a design, which is a big step forward, but the devil is in the little details.",
		"a": "I believe I've worked through all those little details over the\n\nlast year and a half while coding it, and there were a lot of them.\n\nThe functional details are not covered in the paper, but the\n\nsourcecode is coming soon. I sent you the main files.\n\n(available by request at the moment, full release soon)"
	},
	{
		"date": "2009-01-16 16:03:14",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2009-January/015014.html",
		"q": "Yea, that was the primary feature that caught my eye. The real trick will be to get people to actually value the BitCoins so that they become currency.",
		"a": "I would be surprised if 10 years from now we're not using\n\nelectronic currency in some way, now that we know a way to do it\n\nthat won't inevitably get dumbed down when the trusted third party\n\ngets cold feet.\n\nIt could get started in a narrow niche like reward points,\n\ndonation tokens, currency for a game or micropayments for adult\n\nsites. Initially it can be used in proof-of-work applications\n\nfor services that could almost be free but not quite.\n\nIt can already be used for pay-to-send e-mail. The send dialog is\n\nresizeable and you can enter as long of a message as you like.\n\nIt's sent directly when it connects. The recipient doubleclicks\n\non the transaction to see the full message. If someone famous is\n\ngetting more e-mail than they can read, but would still like to\n\nhave a way for fans to contact them, they could set up Bitcoin and\n\ngive out the IP address on their website. \"Send X bitcoins to my\n\npriority hotline at this IP and I'll read the message personally.\"\n\nSubscription sites that need some extra proof-of-work for their\n\nfree trial so it doesn't cannibalize subscriptions could charge\n\nbitcoins for the trial.\n\nIt might make sense just to get some in case it catches on. If\n\nenough people think the same way, that becomes a self fulfilling\n\nprophecy. Once it gets bootstrapped, there are so many\n\napplications if you could effortlessly pay a few cents to a\n\nwebsite as easily as dropping coins in a vending machine."
	},
	{
		"date": "2009-01-25 15:47:10",
		"src": "http://www.metzdowd.com/pipermail/cryptography/2009-January/015041.html",
		"q": "If POW tokens do become useful, and especially if they become money, machines will no longer sit idle. Users will expect their computers to be earning them money (assuming the reward is greater than the cost to operate). A computer whose earnings are being stolen by a botnet will be more noticeable to its owner than is the case today, hence we might expect that in that world, users will work harder to maintain their computers and clean them of botnet infestations.",
		"a": "there would be a profit motive for people to set up massive\n\nquantities of fake e-mail accounts to harvest POW tokens from\n\nspam. They'd essentially be reverse-spamming the spammers with\n\nautomated mailboxes that collect their POW and don't read the\n\nmessage. The ratio of fake mailboxes to real people could become\n\ntoo high for spam to be cost effective.\n\nThe process has the potential to establish the POW token's value\n\nin the first place, since spammers that don't have a botnet could\n\nbuy tokens from harvesters. While the buying back would\n\ntemporarily let more spam through, it would only hasten the\n\nself-defeating cycle leading to too many harvesters exploiting the\n\nspammers.\n\nInterestingly, one of the e-gold systems already has a form of\n\nspam called \"dusting\". Spammers send a tiny amount of gold dust\n\nin order to put a spam message in the transaction's comment field.\n\nIf the system let users configure the minimum payment they're\n\nwilling to receive, or at least the minimum that can have a\n\nmessage with it, users could set how much they're willing to get\n\npaid to receive spam."
	},
	{
		"date": "2009-01-16 18:35:32",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21356305/",
		"q": "Yea, that was the primary feature that caught my eye. The real trick will be to get people to actually value the BitCoins so that they become currency.",
		"a": "I would be surprised if 10 years from now we're not using\n\nelectronic currency in some way, now that we know a way to do it\n\nthat won't inevitably get dumbed down when the trusted third party\n\ngets cold feet.\n\nIt could get started in a narrow niche like reward points,\n\ndonation tokens, currency for a game or micropayments for adult\n\nsites. Initially it can be used in proof-of-work applications\n\nfor services that could almost be free but not quite.\n\nIt can already be used for pay-to-send e-mail. The send dialog is\n\nresizeable and you can enter as long of a message as you like.\n\nIt's sent directly when it connects. The recipient doubleclicks\n\non the transaction to see the full message. If someone famous is\n\ngetting more e-mail than they can read, but would still like to\n\nhave a way for fans to contact them, they could set up Bitcoin and\n\ngive out the IP address on their website. \"Send X bitcoins to my\n\npriority hotline at this IP and I'll read the message personally.\"\n\nSubscription sites that need some extra proof-of-work for their\n\nfree trial so it doesn't cannibalize subscriptions could charge\n\nbitcoins for the trial.\n\nIt might make sense just to get some in case it catches on. If\n\nenough people think the same way, that becomes a self fulfilling\n\nprophecy. Once it gets bootstrapped, there are so many\n\napplications if you could effortlessly pay a few cents to a\n\nwebsite as easily as dropping coins in a vending machine."
	},
	{
		"date": "2009-01-25 16:45:25",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21424626/",
		"q": "I have had a couple of problems running bitcoin: is this an appropriate list for reporting them (with about 70kb of attachments)?",
		"a": "What's the problem you're having?\n\nIf you send me your debug.log file directly (best not to send attachments\n\nto the list), I can take a look at what's happening.\n\nbitcoin-help at vistomail dot com"
	},
	{
		"date": "2009-02-22 17:47:52",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21646307/",
		"q": "What's next?",
		"a": "The next thing for v0.1.6 is to take advantage of multiple\n\nprocessors to generate blocks. Currently it only starts one\n\nthread. If you have a multi-core processor like a Core Duo or\n\nQuad this will double or quadruple your production.\n\nLater I want to add interfaces to make it really easy to integrate\n\ninto websites from any server side language."
	},
	{
		"date": "2009-03-04 16:59:12",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21740046/",
		"q": "That sounds good. I'd also like to be able to run multiple coin/block generators on multiple machines, all behind a single NAT address. I haven't tried this yet so I don't know if it works on the current software.",
		"a": "The current version will work fine. They'll each connect over the\n\nInternet, while incoming connections only come to the host that\n\nport 8333 is routed to.\n\nAs an optimisation, I'll make a switch \"-connect=1.2.3.4\" to make\n\nit only connect to a specific address. You could make your extra\n\nnodes connect to your primary, and only the primary connects over\n\nthe Internet. It doesn't really matter for now, since the network\n\nwould have to get huge before the bandwidth is anything more than\n\ntrivial."
	},
	{
		"date": "2009-03-04 16:59:12",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21740046/",
		"q": "BTW I don't remember if we talked about this, but the other day some people were mentioning secure timestamping. You want to be able to prove that a certain document existed at a certain time in the past. Seems to me that bitcoin's stack of blocks would be perfect for this.",
		"a": "Indeed, Bitcoin is a distributed secure timestamp server for\n\ntransactions. A few lines of code could create a transaction with\n\nan extra hash in it of anything that needs to be timestamped.\n\nI should add a command to timestamp a file that way."
	},
	{
		"date": "2009-03-04 16:59:12",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/21740046/",
		"q": "Right, and I'd like to see more of a library interface that could be called from programming or scripting languages, on the client side as well.",
		"a": "Exactly."
	},
	{
		"date": "2009-10-23 23:57:51",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/23824064/",
		"q": "Do you Windows users experience occasional Bitcoin crashes? Lately Bitcoin running in wine-1.0.1 has been crashing frequently. I was just wondering whether this is a Wine issue or a Bitcoin issue.",
		"a": "I haven't had any reports of crashes in v0.1.5. It's been rock solid\n\nfor me on Windows. I think it must be Wine related. If you get another\n\ncrash in Wine and it prints anything on the terminal, e-mail me and I\n\nmay be able to figure out what happened, maybe something I can work\n\naround. Martti and I have been working on a new version to release soon\n\nand it would be nice to get any Wine fixes in there."
	},
	{
		"date": "2009-10-23 23:57:51",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/23824064/",
		"q": "The following four lines print from the terminal when I start Bitcoin. fixme:toolhelp:CreateToolhelp32Snapshot Unimplemented: heap list snapshot fixme:toolhelp:Heap32ListFirst : stub fixme:toolhelp:CreateToolhelp32Snapshot Unimplemented: heap list snapshot fixme:toolhelp:Heap32ListFirst : stub",
		"a": "Those don't look like anything to worry about. Probably functions\n\nunimplemented by Wine that are harmlessly stubbed out."
	},
	{
		"date": "2009-10-23 23:57:51",
		"src": "https://sourceforge.net/p/bitcoin/mailman/message/23824064/",
		"q": "I previously wasn't starting Bitcoin from the terminal, so I don't know what gets printed out when it crashes, but I'll reply with the results the next time it crashes.\n\nWhile Bitcoin first downloads previously completed blocks, the file debug.log grows grows to 17.4 MB and then stops growing. I imagine it will continue to grow as more bitcoins are completed.",
		"a": "You can delete debug.log occasionally if you don't want to take the disk\n\nspace. It's just status messages that help with debugging.\n\nbitcoin.sourceforge.net looks fine now. Maybe sourceforge was doing\n\nsome maintenance."
	}
]